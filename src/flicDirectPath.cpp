/*
  Research carried out within the scope of the Associated International Laboratory: Joint Japanese-French Robotics Laboratory (JRL)
 
  Developed by Florent Lamiraux
           and Mathieu Poirier (LAAS-CNRS)
 
*/

#define DEBUG_OUTPUT 0

/*****************************************
INCLUDES
*******************************************/

#include <math.h>
#include <fstream>
#include "KineoWorks2/kwsDevice.h" // without this causes error when calling functions of kwsDevice
#include "kwsioInterface.h"
#include "flicManager.h"



CflicPolynomial3::CflicPolynomial3(double u1, double u2, double valueU1, double valueU2,
                                   double valueDerivU1, double valueDerivU2):
    attU1(u1),attU2(u2),attValueU1(valueU1),attValueU2(valueU2),
    attValueDerivU1(valueDerivU1),attValueDerivU2(valueDerivU2)
{
  computeDerivativeBounds();
}


//==============================================================================

double CflicPolynomial3::value(double u) const
{

  /* derivee de phi par rapport a la courbure aux extremites */
  double h = attU2-attU1;
  double h2 = h*h;
  double h3 = h2*h;

  double du = u-attU1;
  double du2 = du*du;
  double du3 = du*du2;

  double dy = attValueU2-attValueU1;

  double val = -(2*dy-h*(attValueDerivU1+attValueDerivU2))*du3/h3 - (-3*dy*h+attValueDerivU2*h2+2*attValueDerivU1*h2)*du2/h3+attValueDerivU1*du+attValueU1;

  return val;
}


//==============================================================================

double CflicPolynomial3::valueDeriv(double u) const
{
  double derivative = -3*(2*attValueU2-2*attValueU1-(attU2-attU1)*(attValueDerivU1+attValueDerivU2))*pow((u-attU1),2.0)*pow((attU2-attU1),-3.0)
                      -2*(-3*(attValueU2-attValueU1)*(attU2-attU1)+attValueDerivU2*pow((attU2-attU1),2.0)+2*attValueDerivU1*pow((attU2-attU1),2.0))*(u-attU1)*pow((attU2-attU1),-3.0)+attValueDerivU1;

  return derivative;
}

//==============================================================================

double CflicPolynomial3::valueDeriv2(double u) const
{
  double derivative = -6*(2*attValueU2-2*attValueU1-(attU2-attU1)*(attValueDerivU1+attValueDerivU2))*pow((attU2-attU1),-3.0)*(u-attU1)
                      -2*(-3*(attValueU2-attValueU1)*(attU2-attU1)+attValueDerivU2*pow((attU2-attU1),2.0)+2*attValueDerivU1*pow((attU2-attU1),2.0))*pow((attU2-attU1),-3.0);

  return derivative;
}

//==============================================================================

double CflicPolynomial3::maxAbsDeriv1() const
{
  if (!flagDerivativeBounds)
  {
    return -1;
  }
  return attMaxAbsDeriv1;
}

//==============================================================================

double CflicPolynomial3::maxAbsDeriv2() const
{
  if (!flagDerivativeBounds)
  {
    return -1;
  }
  return attMaxAbsDeriv2;
}

//==============================================================================

double CflicPolynomial3::maxAbsDeriv3() const
{
  if (!flagDerivativeBounds)
  {
    return -1;
  }
  return attMaxAbsDeriv3;
}

/*****************************************
 PRIVATE METHODS
*****************************************/


//==============================================================================

// Code generated by maple.

void CflicPolynomial3::computeCoefficients(double coef[4]) const
{
  // Coefficient of u^3.
  coef[3] = (-2 * attValueU1 + attU1 * attValueDerivU2 + attU1 * attValueDerivU1 - attU2 * attValueDerivU2 - attU2 * attValueDerivU1 + 2 * attValueU2) / ( pow((double) attU1, (double) 3) - 3 * attU2 * attU1 * attU1 -  pow((double) attU2, (double) 3) + 3 * attU1 * attU2 * attU2);
  // Coefficient of u^2.
  coef[2] = -(2 * attU1 * attU1 * attValueDerivU2 + attU1 * attU1 * attValueDerivU1 - 3 * attU1 * attValueU1 - attU1 * attU2 * attValueDerivU2 + 3 * attU1 * attValueU2 + attU1 * attU2 * attValueDerivU1 - 2 * attU2 * attU2 * attValueDerivU1 - 3 * attU2 * attValueU1 - attU2 * attU2 * attValueDerivU2 + 3 * attU2 * attValueU2) / ( pow((double) attU1, (double) 3) - 3 * attU2 * attU1 * attU1 -  pow((double) attU2, (double) 3) + 3 * attU1 * attU2 * attU2);
  // Coefficient of u.
  coef[1] = (pow(attU1, 0.3e1) * attValueDerivU2 + attU1 * attU1 * attU2 * attValueDerivU2 + 0.2e1 * attU1 * attU1 * attU2 * attValueDerivU1 - attU2 * attU2 * attU1 * attValueDerivU1 - 0.6e1 * attU1 * attU2 * attValueU1 - 0.2e1 * attU2 * attU2 * attU1 * attValueDerivU2 + 0.6e1 * attU1 * attU2 * attValueU2 - pow(attU2, 0.3e1) * attValueDerivU1) / (pow(attU1, 0.3e1) - 0.3e1 * attU2 * attU1 * attU1 - pow(attU2, 0.3e1) + 0.3e1 * attU1 * attU2 * attU2);
  // Constant coefficient.
  coef[0] = -(attValueU1 * pow(attU2, 0.3e1) - 0.3e1 * attValueU1 * attU1 * attU2 * attU2 + pow(attU1, 0.3e1) * attU2 * attValueDerivU2 - pow(attU1, 0.3e1) * attValueU2 + attU1 * attU1 * attU2 * attU2 * attValueDerivU1 - attU1 * attU1 * attU2 * attU2 * attValueDerivU2 + 0.3e1 * attU1 * attU1 * attU2 * attValueU2 - attU1 * attValueDerivU1 * pow(attU2, 0.3e1)) / (pow(attU1, 0.3e1) - 0.3e1 * attU2 * attU1 * attU1 - pow(attU2, 0.3e1) + 0.3e1 * attU1 * attU2 * attU2);

}


//==============================================================================

void CflicPolynomial3::computeDerivativeBounds()
{
  double coef[4];

  computeCoefficients(coef);

  // First derivative : P'(u) = 3 a3 u^2 + 2 a2 u + a1 = a u^2 + b u + c.
  double a = 3*coef[3];
  double b = 2*coef[2];
  double c = coef[1];

  if (fabs(a) < 1e-8)
  {
    if (fabs(b) < 1e-8)
    {
      // Polynomial is of degree 1, first derivative is constant.
      attMaxAbsDeriv1 = fabs(c);
      attMaxAbsDeriv2 = 0;
    }
    else
    {
      // Polynomial is of degree 2, first derivative is of degree 1.
      // Maximum of first derivative absolute value is reached at one of the bounds of the definition interval.
      attMaxAbsDeriv1 = max(fabs(b*attU1 + c), fabs(b*attU2 + c));
      // Second derivative is constant.
      attMaxAbsDeriv2 = fabs(b);
    }
  }
  else
  {
    // Polynomial is of degree 3, first derivative is of degree 2.
    // Interval bounds are potential parameter values for maximum absolute derivative.
    attMaxAbsDeriv1 = max(fabs(a*pow(attU1,2.0) + b*attU1 + c),
                          fabs(a*pow(attU2,2.0) + b*attU2 + c));
    // Potential maximal absolute value of first derivative can be reached at u = -b/(2a)
    // if this value is inside definition interval.
    double minusBover2a = -b/(2*a);

    if ((attU1 < minusBover2a ) && (minusBover2a < attU2))
    {
      // -b/(2a) is inside definition interval. Maximum absolute value
      // of first derivative might be reached for this parameter value.
      attMaxAbsDeriv1 = max(attMaxAbsDeriv1, fabs(a*pow(minusBover2a,2.0) + b*minusBover2a + c));
    }
    // Second derivative
    // P''(u) = 2a u + b
    // is of degree 1. Maximum absolute value reached at one bound of
    // definition interval.
    attMaxAbsDeriv2 = max (fabs(2*a*attU1+b), fabs(2*a*attU2+b));
  }
  // Third derivative is constant.
  attMaxAbsDeriv3 = 2*a;

  flagDerivativeBounds = true;
}




// ==============================================================================
//
//  METHOD OF CLASS CflicPiecewisePolynomial3
//
// ==============================================================================




/*****************************************
 PUBLIC METHODS
*****************************************/



CflicPiecewisePolynomial3::CflicPiecewisePolynomial3(unsigned int inNbIntervals, double inUmin, double inUmax):
    attUmin(inUmin),attUmax(inUmax),attNbIntervals(inNbIntervals),attVectorPoly(inNbIntervals)
{
  double sampleStep = (inUmax - inUmin)/inNbIntervals;
  // Fill definition interval for each polynomial.
  for (unsigned int iInterval=0; iInterval < inNbIntervals; iInterval++)
  {
    attVectorPoly[iInterval].attU1 = inUmin + iInterval*sampleStep;
    attVectorPoly[iInterval].attU2 = inUmin + (iInterval+1)*sampleStep;
  }
}


//==============================================================================

void CflicPiecewisePolynomial3::computeDerivativeBounds()
{
  std::vector<CflicPolynomial3>::iterator iter;
  for (iter=attVectorPoly.begin(); iter < attVectorPoly.end(); iter++)
  {
    iter->computeDerivativeBounds();
  }
}


//==============================================================================

ktStatus CflicPiecewisePolynomial3::setDefIntervalBounds()
{
  unsigned int vectorSize = attVectorPoly.size();
  if (vectorSize == 0)
  {
    cerr << "CflicPiecewisePolynomial3::setDefIntervalBounds: vector of polynomials is empty." << endl;
    return KD_ERROR;
  }
  attUmin = attVectorPoly[0].attU1;
  attUmax = attVectorPoly[vectorSize-1].attU2;

  return KD_OK;
}


//==============================================================================

double CflicPiecewisePolynomial3::value(double u) const
{
  if (attUmax <= attUmin)
  {
    cerr << "CflicPiecewisePolynomial3::value: attUmax <= attUmin. attUmin = "
    << attUmin << ", attUmax = " << attUmax << endl;
    return 0;
  }

  unsigned int polyId = (unsigned int)floor((u-attUmin)/(attUmax-attUmin)*attNbIntervals);
  if (u == attUmax)
  {
    polyId = attNbIntervals-1;
  }
  const CflicPolynomial3& poly3 = attVectorPoly[polyId];

  double val = poly3.value(u);
  return val;
}

//==============================================================================

double CflicPiecewisePolynomial3::valueDeriv(double u) const
{
  if (attUmax <= attUmin)
  {
    cerr << "CflicPiecewisePolynomial3::valueDeriv: attUmax <= attUmin" << endl;
    return 0;
  }

  unsigned int polyId = (unsigned int)floor((u-attUmin)/(attUmax-attUmin)*attNbIntervals);
  if (u == attUmax)
  {
    polyId = attNbIntervals-1;
  }
  const CflicPolynomial3& poly3 = attVectorPoly[polyId];

  if ((u < poly3.attU1) || (u > poly3.attU2))
  {
    cerr << "CflicPiecewisePolynomial3::valueDeriv: u out of range"
    << ", poly3.attU1 = " << poly3.attU1
    << ", poly3.attU2 = " << poly3.attU2
    << ", polyId = " << polyId
    << ", attNbIntervals = " << attNbIntervals
    << endl;
  }
  double valueDeriv = poly3.valueDeriv(u);
  return valueDeriv;
}


//==============================================================================

ktStatus CflicPiecewisePolynomial3::u1(unsigned int rank, double inU1)
{
  if (rank >= attVectorPoly.size())
  {
    cerr << "CflicPiecewisePolynomial3::u1: rank bigger than vector size. rank = "
    << rank << "vector size = " << attVectorPoly.size() << endl;
    return KD_ERROR;
  }
  attVectorPoly[rank].attU1 = inU1;
  return KD_OK;
}

//==============================================================================

ktStatus CflicPiecewisePolynomial3::u2(unsigned int rank, double inU2)
{
  if (rank >= attVectorPoly.size())
  {
    cerr << "CflicPiecewisePolynomial3::u2: rank bigger than vector size. rank = "
    << rank << "vector size = " << attVectorPoly.size() << endl;
    return KD_ERROR;
  }
  attVectorPoly[rank].attU2 = inU2;
  return KD_OK;
}

//==============================================================================

ktStatus CflicPiecewisePolynomial3::valueU1(unsigned int rank, double inValueU1)
{
  if (rank >= attVectorPoly.size())
  {
    cerr << "CflicPiecewisePolynomial3::valueU1: rank bigger than vector size. rank = "
    << rank << "vector size = " << attVectorPoly.size() << endl;
    return KD_ERROR;
  }
  attVectorPoly[rank].attValueU1 = inValueU1;
  return KD_OK;
}

//==============================================================================

ktStatus CflicPiecewisePolynomial3::valueU2(unsigned int rank, double inValueU2)
{
  if (rank >= attVectorPoly.size())
  {
    cerr << "CflicPiecewisePolynomial3::valueU2: rank bigger than vector size. rank = "
    << rank << "vector size = " << attVectorPoly.size() << endl;
    return KD_ERROR;
  }
  attVectorPoly[rank].attValueU2 = inValueU2;
  return KD_OK;
}

//==============================================================================

ktStatus CflicPiecewisePolynomial3::valueDerivU1(unsigned int rank, double inValueDerivU1)
{
  if (rank >= attVectorPoly.size())
  {
    cerr << "CflicPiecewisePolynomial3::valueDerivU1: rank bigger than vector size. rank = "
    << rank << "vector size = " << attVectorPoly.size() << endl;
    return KD_ERROR;
  }
  attVectorPoly[rank].attValueDerivU1 = inValueDerivU1;
  return KD_OK;
}

//==============================================================================

ktStatus CflicPiecewisePolynomial3::valueDerivU2(unsigned int rank, double inValueDerivU2)
{
  if (rank >= attVectorPoly.size())
  {
    cerr << "CflicPiecewisePolynomial3::valueDerivU2: rank bigger than vector size. rank = "
    << rank << "vector size = " << attVectorPoly.size() << endl;
    return KD_ERROR;
  }
  attVectorPoly[rank].attValueDerivU2 = inValueDerivU2;
  return KD_OK;
}


//==============================================================================

std::vector<CflicPolynomial3>::const_iterator CflicPiecewisePolynomial3::begin() const
{
  std::vector<CflicPolynomial3>::const_iterator iter = attVectorPoly.begin();
  return iter;
}

//==============================================================================

std::vector<CflicPolynomial3>::const_iterator CflicPiecewisePolynomial3::end() const
{
  std::vector<CflicPolynomial3>::const_iterator iter = attVectorPoly.end();
  return iter;
}

// ==============================================================================
//
//  METHOD OF CLASS CflicBoundManagerDefParam
//
// ==============================================================================

void CflicBoundManagerDefParam::getBoundsNormGamma1(double uMin, double uMax, double& valueMin, double& valueMax)
{
  getBoundsOnInterval(boundListDeriv1, uMin, uMax, valueMin, valueMax);
}

//==============================================================================

void CflicBoundManagerDefParam::getBoundsNormGamma2(double uMin, double uMax, double& valueMin, double& valueMax)
{
  getBoundsOnInterval(boundListDeriv2, uMin, uMax, valueMin, valueMax);
}


//==============================================================================

void  CflicBoundManagerDefParam::getBoundsOnInterval(std::list<TflicBoundInterval> boundIntervalList, double uMin, double uMax, double &valueMin, double &valueMax)
{

  //-----debug
  //cout << " =====VERIF LISTE===== " << endl ;
  //for( std::list<TflicBoundInterval>::iterator itera = liste.begin(); itera !=liste.end() ; itera++ ) {
  //  cout << itera->uMin << "\t" << itera->uMax << "\t" << itera->valueMin << "\t" << itera->valueMax << endl ;
  //}
  //cout << " Get bounds Intervale " << endl ;
  //----------------------------------



  bool find = false ;

  std::list<TflicBoundInterval>::iterator iter = boundIntervalList.begin() ;

  while ((iter != boundIntervalList.end()) && !find )
  {
    if ((iter->uMin <= uMin) && (uMin < iter->uMax) ) find = true ;
    else iter++ ;
  }

  find = false ;

  valueMin = iter->valueMin ;
  valueMax = iter->valueMax ;


  while( (iter != boundIntervalList.end()) && !find )
  {
    if (iter->valueMin <= valueMin) valueMin = iter->valueMin ;
    if (iter->valueMax >= valueMax) valueMax = iter->valueMax ;
    if ((iter->uMin < uMax) && (uMax <= iter->uMax )) find = true ;

    iter ++ ;
  }


}

//==============================================================================

CflicBoundManagerDefParam::CflicBoundManagerDefParam(CflicDirectPathShPtr inDirectPath,
    const CkwsConfig &inStartCfg,
    const CkwsConfig &inEndCfg) :
    startCfg(inStartCfg),
    endCfg(inEndCfg),
    attMaxNbIntervals(0),
    attMaxCurvature(inDirectPath->attMaxCurvature)
{
  //debug
  //cout << " CONSTRUCTEUR MANAGER  " << endl ;
  //------------------

  // Configuration convertion
  // assume that root joint is freeflyer
  flatStartCfg.kappa = inStartCfg.dofValue(CflicDirectPath::CURV_COORD) ; //Kappa (dof fictif)
  flatStartCfg.xp = inStartCfg.dofValue(CflicDirectPath::X_COORD) ;  // x
  flatStartCfg.yp = inStartCfg.dofValue(CflicDirectPath::Y_COORD) ;  // y
  flatStartCfg.tau = inStartCfg.dofValue(CflicDirectPath::RZ_COORD) ; // theta

  flatEndCfg.kappa = inEndCfg.dofValue(CflicDirectPath::CURV_COORD) ; //Kappa (dof fictif)
  flatEndCfg.xp = inEndCfg.dofValue(CflicDirectPath::X_COORD) ;  // x
  flatEndCfg.yp = inEndCfg.dofValue(CflicDirectPath::Y_COORD) ;  // y
  flatEndCfg.tau = inEndCfg.dofValue(CflicDirectPath::RZ_COORD) ; // theta

  attFlatV2 = inDirectPath->flatV2();

  M3 = computeUpperBoundGamma3();

  boundListDeriv1.clear();
  boundListDeriv2.clear();

  //debug
  //cout << "M3 : "  << M3  << " V2 : " << attFlatV2 << endl ;
  //--------------------------------
}

//==============================================================================

CflicBoundManagerDefParam::~CflicBoundManagerDefParam()
{
  // debug
  // cout << "Destructor of CflicBoundManagerDefParam" << endl;
  //----------------------
}

//==============================================================================

ktStatus CflicBoundManagerDefParam::recursiveBuildBoundLists(unsigned int maxNbIntervals,
							     TflicBoundInterval currentBoundInterval1,
							     TflicBoundInterval currentBoundInterval2,
							     TflicBoundInterval& currentBoundIntervalCurv)
{

  // find the intersection point
  double valueUmin =  computeValueGamma2(currentBoundInterval2.uMin) ;
  double valueUmax =  computeValueGamma2(currentBoundInterval2.uMax) ;
  CflicManager::computeFunctionBoundsFromDerivativeUpperBound(currentBoundInterval2, valueUmin,
      valueUmax, M3);

  double gamma2Min = currentBoundInterval2.valueMin;
  double gamma2Max = currentBoundInterval2.valueMax;

  valueUmin = computeValueGamma1(currentBoundInterval1.uMin) ;
  valueUmax = computeValueGamma1(currentBoundInterval1.uMax) ;
  CflicManager::computeFunctionBoundsFromDerivativeUpperBound(currentBoundInterval1, valueUmin,
						valueUmax,
						currentBoundInterval2.valueMax);

  double gamma1Min = currentBoundInterval1.valueMin;
  if (gamma1Min <= 0) {
    gamma1Min = 1e-10;
  }
  double gamma1Max = currentBoundInterval1.valueMax;

  // Commpute bounds on curvature
  // The following is not exactly a lower bound of curvature.
  // As a consequence, some local paths might be rejected although they satisfy curvature bounds.
  double lowerBoundCurvature = gamma1Min*gamma2Min/pow(gamma1Max, 3.0);
  double upperBoundCurvature = gamma1Max*gamma2Max/pow(gamma1Min, 3.0);
  if (lowerBoundCurvature > attMaxCurvature) {
#if DEBUG_OUTPUT
    std::cerr << "CflicarBoundManagerDefParam::recursiveBuildBoundLists: curvature overflow" << std::endl;
    std::cerr << "lowerBoundCurvature = " << lowerBoundCurvature << " attMaxCurvature = " << attMaxCurvature
	      << std::endl;
#endif
    return KD_ERROR;
  }
  currentBoundIntervalCurv.valueMin = lowerBoundCurvature;
  currentBoundIntervalCurv.valueMax = upperBoundCurvature;
  
  // Test Threshold on gamma' norm
  if (currentBoundInterval1.valueMax <= minNormGamma1)
  {

    //cerr << " FAILURE -- currentBoundInterval1.valueMax <= minNormGamma1 " << currentBoundInterval1.valueMax <<" <= " << minNormGamma1 << endl ;

    return KD_ERROR;
  }
  // Test stop condition
  if (currentBoundInterval1.valueMax - currentBoundInterval1.valueMin < maxDistBetweenLowerAndUpperBound)
  {

    boundListDeriv1.push_back(currentBoundInterval1);
    boundListDeriv2.push_back(currentBoundInterval2);
    // Update maximal recursivity order.
    if (attMaxNbIntervals < maxNbIntervals)
    {
      attMaxNbIntervals = maxNbIntervals;
    }

    return KD_OK;
  }
  else
  {
    // Split interval.
    double uMin = currentBoundInterval1.uMin;
    double uMax = currentBoundInterval1.uMax;
    double uMiddle = 0.5*(uMin+uMax);

    TflicBoundInterval firstIntervalGamma1, firstIntervalGamma2 ;
    TflicBoundInterval secondIntervalGamma1, secondIntervalGamma2;

    // First sub-interval
    firstIntervalGamma2.uMin = uMin ;
    firstIntervalGamma2.uMax = uMiddle ;

    firstIntervalGamma1.uMin = uMin ;
    firstIntervalGamma1.uMax = uMiddle ;

    // Second sub-interval
    secondIntervalGamma2.uMin = uMiddle ;
    secondIntervalGamma2.uMax = uMax ;

    secondIntervalGamma1.uMin = uMiddle ;
    secondIntervalGamma1.uMax = uMax ;

    if ((recursiveBuildBoundLists(2*maxNbIntervals, firstIntervalGamma1, firstIntervalGamma2,
				  currentBoundIntervalCurv) == KD_OK) &&
        (recursiveBuildBoundLists(2*maxNbIntervals, secondIntervalGamma1, secondIntervalGamma2,
				  currentBoundIntervalCurv) == KD_OK))
    {
      return KD_OK;
    }
    else return KD_ERROR ;
  }

}


// ==============================================================================

ktStatus CflicBoundManagerDefParam::buildBoundLists()
{

  ktStatus status = KD_OK ;

  //initialisation
  TflicBoundInterval boundIntervalGamma1, boundIntervalGamma2, boundIntervalCurvature;


  maxDistBetweenLowerAndUpperBound = sqrt(pow(flatEndCfg.xp-flatStartCfg.xp, 2.0) + pow(flatEndCfg.yp-flatStartCfg.yp, 2.0))/20;
  minNormGamma1 = 2*maxDistBetweenLowerAndUpperBound;

  if (maxDistBetweenLowerAndUpperBound < 10e-8)
  {

    //debug
    //cerr << " FAILURE  ---  maxDistBetweenLowerAndUpperBound < 10e-8 : " << maxDistBetweenLowerAndUpperBound << endl ;

    return KD_ERROR;
  }

  boundIntervalGamma2.uMin = 0 ;
  boundIntervalGamma2.uMax = 1 ;
  boundIntervalGamma2.valueMax = 0 ;
  boundIntervalGamma2.valueMin = 0 ;

  boundIntervalGamma1.uMin = 0 ;
  boundIntervalGamma1.uMax = 1 ;
  boundIntervalGamma1.valueMax = 0 ;
  boundIntervalGamma1.valueMin = 0 ;

  boundIntervalCurvature.uMin = 0;
  boundIntervalCurvature.uMax = 1;
  boundIntervalCurvature.valueMax = 0;
  boundIntervalCurvature.valueMin = 0;

#if DEBUG_OUTPUT
  std::cerr << "attMaxCurvature=" << attMaxCurvature << std::endl;
#endif

  status = recursiveBuildBoundLists(1, boundIntervalGamma1, boundIntervalGamma2,
				    boundIntervalCurvature);

  return status ;

}


// ==============================================================================

double CflicBoundManagerDefParam::computeUpperBoundGamma3()
{
  double maxGamma3;

  double tau1 = flatStartCfg.tau ;
  double tau2 = flatEndCfg.tau ;
  double kap1 = flatStartCfg.kappa ;
  double kap2 = flatEndCfg.kappa ;
  double tauB2 = tau2 - kap2*fabs(attFlatV2) ;

  // ||Gamma2(0)-Gamma1(0)||
  double tabDeriv[6] ;
  CflicManager::flatGamma(&flatEndCfg, -attFlatV2, 2, tabDeriv ) ;
  double normeGamma0 = sqrt(pow(tabDeriv[0]-flatStartCfg.xp, 2.0)+pow(tabDeriv[1]-flatStartCfg.yp,2.0)) ;

  // debug
  //cout << "tau1 : " << tau1 << " tau2 : " << tau2 <<" kap1 : " << kap1 <<" kap2 : " << kap2 <<" tauB2 : " << tauB2 << " normeGamma0 : " << normeGamma0 << endl ;
  //-----------------------------

  maxGamma3 =	fabs(pow(kap1,2)*pow(attFlatV2,3)) +
              fabs(pow(kap2,2)*pow(attFlatV2,3)) +
              3*45/8*pow(attFlatV2, 2) * ( fabs(kap2) * (fabs( tau1 - tauB2 ) + fabs (kap1-kap2) *fabs(attFlatV2) ) + fabs( kap2 - kap1) ) +
              3*17.319*fabs(attFlatV2) * (fabs( tauB2 - tau1 ) + fabs(kap2-kap1) * fabs(attFlatV2) ) +
              60 * ( normeGamma0  + fabs(attFlatV2)*fabs(tauB2-tau1) + fabs(kap2-kap1) * pow(attFlatV2,2)/2)  ;

  return maxGamma3;
}


// ==============================================================================
double CflicBoundManagerDefParam::computeValueGamma2(double u)
{

  double tabDeriv[6] ;

  CflicManager::flatCombination(&flatStartCfg, &flatEndCfg, u, attFlatV2, 2, tabDeriv) ;

  return sqrt(pow(tabDeriv[4], 2)  + pow(tabDeriv[5], 2))  ;

}

// ==============================================================================
double CflicBoundManagerDefParam::computeValueGamma1(double u)
{


  double tabDeriv[6] ;

  CflicManager::flatCombination(&flatStartCfg, &flatEndCfg, u, attFlatV2, 2, tabDeriv) ;

  return sqrt(pow(tabDeriv[2], 2)  + pow(tabDeriv[3], 2))  ;

}











// ==============================================================================
//
//  METHOD OF CLASS CflicArcLengthManager
//
// ==============================================================================



/*****************************************
 PUBLIC METHODS
*****************************************/



CflicArcLengthManager::CflicArcLengthManager(unsigned int nbSampleIntervals,
    CflicDirectPathShPtr inDirectPath):
    attDefaultToArcLength(nbSampleIntervals, 0.0, 1.0), attArcLengthToDefault(nbSampleIntervals)
{
  attNbSampleIntervals = nbSampleIntervals;

  // Build mapping between default parameter and arc-length parameter.
  buildMappingDefaultToArcLength(inDirectPath);
  // Build mapping between arc-length parameter and default parameter.
  buildMappingArcLengthToDefault();
}


// ==============================================================================


double CflicArcLengthManager::defaultParam(double arcLength)
{
  double defaultParam = attArcLengthToDefault.value(arcLength);
  return defaultParam;
}

/*****************************************
 PRIVATE METHODS
*****************************************/

void CflicArcLengthManager::buildMappingDefaultToArcLength(CflicDirectPathShPtr inDirectPath)
{
  double sampleStep = 1.0/attNbSampleIntervals;
  unsigned int rank=0;

  // Set first sample polynomial.
  double valU1 = 0.0;
  attDefaultToArcLength.valueU1(rank, 0.0);
  double valDerivU1 = inDirectPath->normGammaDeriv1(0);
  attDefaultToArcLength.valueDerivU1(rank, valDerivU1);
  double valDerivU2 = inDirectPath->normGammaDeriv1(sampleStep);
  attDefaultToArcLength.valueDerivU2(rank, valDerivU2);
  double mediumValDeriv = inDirectPath->normGammaDeriv1(.5*sampleStep);
  // Simpson integral
  double valU2 = sampleStep*(valDerivU1 + 4*mediumValDeriv + valDerivU2)/6.0;
  attDefaultToArcLength.valueU2(rank, valU2);

  rank++;

  double prevValU2 = valU2;
  double prevValDerivU2 = valDerivU2;

  while (rank < attNbSampleIntervals)
  {
    // Arc length is continuous.
    valU1 = prevValU2;
    attDefaultToArcLength.valueU1(rank, valU1);
    // And even of class C^1
    valDerivU1 = prevValDerivU2;
    attDefaultToArcLength.valueDerivU1(rank, valDerivU1);

    // Integrand value in the middle of the interval.
    mediumValDeriv = inDirectPath->normGammaDeriv1((rank+.5)*sampleStep);
    // Integrand value at end of interval.
    valDerivU2 = inDirectPath->normGammaDeriv1((rank+1)*sampleStep);
    attDefaultToArcLength.valueDerivU2(rank, valDerivU2);
    // Simpson integral.
    valU2 = valU1 + sampleStep*(valDerivU1 + 4*mediumValDeriv + valDerivU2)/6.0;
    attDefaultToArcLength.valueU2(rank, valU2);

    prevValU2 = valU2;
    prevValDerivU2 = valDerivU2;
    rank++;
  }
  attArcLength = prevValU2;
}


// ==============================================================================


void CflicArcLengthManager::buildMappingArcLengthToDefault()
{
  unsigned int rank=0;
  double sampleStep = attArcLength/attNbSampleIntervals;

  //std::vector<CflicPolynomial3>::iterator arcLengthToDefPolyIter = attArcLengthToDefault.begin();
  //std::vector<CflicPolynomial3>::iterator prevArcLengthToDefPolyIter;

  // Fill first interval data
  // interval of definition is [0,sampleStep].
  attArcLengthToDefault.u1(rank, 0);
  attArcLengthToDefault.u2(rank, sampleStep);
  // u(0) = 0
  double valU1 = 0.0;
  attArcLengthToDefault.valueU1(rank, valU1);
  // Find u(sampleStep) by solving equation s(u) = sampleStep.
  double valU2 = findDefaultParameter(sampleStep);
  attArcLengthToDefault.valueU2(rank, valU2);
  // du/ds(0) = 1/(ds/du(0))
  double valDerivU1 = 1.0/attDefaultToArcLength.valueDeriv(0);
  attArcLengthToDefault.valueDerivU1(rank, valDerivU1);
  // du/ds(u2) = 1/(ds/du(s^{-1}(u2)))
  double valDerivU2 = 1.0/attDefaultToArcLength.valueDeriv(valU2);
  attArcLengthToDefault.valueDerivU2(rank, valDerivU2);

  double prevValU2 = valU2;
  double prevValDerivU2 = valDerivU2;
  rank++;

  while (rank < attNbSampleIntervals)
  {

    attArcLengthToDefault.u1(rank, rank*sampleStep);
    attArcLengthToDefault.u2(rank, (rank+1)*sampleStep);

    attArcLengthToDefault.valueU1(rank, prevValU2);
    attArcLengthToDefault.valueDerivU1(rank, prevValDerivU2);

    // Default param at end of interval.
    valU2 = findDefaultParameter((rank+1)*sampleStep);
    attArcLengthToDefault.valueU2(rank, valU2);
    valDerivU2 = 1/attDefaultToArcLength.valueDeriv(valU2);
    attArcLengthToDefault.valueDerivU2(rank, valDerivU2);

    prevValU2 = valU2;
    prevValDerivU2 = valDerivU2;
    rank++;
  }
  attArcLengthToDefault.setDefIntervalBounds();
  attArcLengthToDefault.computeDerivativeBounds();
}

// ==============================================================================


double CflicArcLengthManager::findDefaultParameter(double arcLengthParam)
{
  // If arcLength param is less than 0, return 0.
  if (arcLengthParam <= 0)
  {
    return attDefaultToArcLength.uMin();
  }
  if (arcLengthParam >= attArcLength)
  {
    return attDefaultToArcLength.uMax();
  }

  // Dichotomy
  double middleParam=0, middleValue=0;
  double lowerParam = attDefaultToArcLength.uMin();
  double upperParam = attDefaultToArcLength.uMax();
  double lowerValue = attDefaultToArcLength.value(lowerParam);
  double upperValue = attDefaultToArcLength.value(upperParam);

  while (upperParam - lowerParam > 1e-8)
  {
    //middleParam = lowerParam + (arcLengthParam-lowerValue)/(upperValue-lowerValue)*(upperParam-lowerParam);
    middleParam = .5*(lowerParam + upperParam);
    middleValue = attDefaultToArcLength.value(middleParam);

    if (middleValue > arcLengthParam)
    {
      upperParam = middleParam;
      upperValue = middleValue;
    }
    else
    {
      lowerParam = middleParam;
      lowerValue = middleValue;
    }
  }
  return middleParam;
}

// ==============================================================================
//
//  METHOD OF CLASS CflicBoundManagerArcLengthParam
//
// ==============================================================================



/*****************************************
 PUBLIC METHODS
*****************************************/

void CflicBoundManagerArcLengthParam::getBoundsNormDgammaOverDs(double sMin, double sMax,
    double& valueMin, double& valueMax)
{
  getBoundsOnInterval(boundVectorDeriv1, sMin, sMax, valueMin, valueMax);
}

void CflicBoundManagerArcLengthParam::getBoundsNormD2gammaOverDs2(double sMin, double sMax,
    double& valueMin, double& valueMax)
{
  getBoundsOnInterval(boundVectorDeriv2, sMin, sMax, valueMin, valueMax);
}
/*****************************************
 PRIVATE METHODS
*****************************************/

ktStatus CflicBoundManagerArcLengthParam::buildBoundVectors(CflicDirectPathShPtr inDirectPath)
{
  double sampleStep = attArcLength/attNbSampleIntervals;
  unsigned int iterNb;
  double minGamma2, maxGamma2;
  double minGamma1, maxGamma1;
  double maxGamma3;

  // Iterator over vector of degree 3 polynomials defining mapping from arc length to default param.
  std::vector<CflicPolynomial3>::const_iterator arcLengthToDefaultMappingIter =
    inDirectPath->attArcLengthManager->mappingArcLengthToDefIterBegin();

  for(iterNb = 0; iterNb < attNbSampleIntervals; iterNb++)
  {
    double sMin = iterNb*sampleStep;
    double sMax = (iterNb+1)*sampleStep;
    // Set definition interval.
    boundVectorDeriv1[iterNb].uMin = sMin;
    boundVectorDeriv1[iterNb].uMax = sMax;
    boundVectorDeriv2[iterNb].uMin = sMin;
    boundVectorDeriv2[iterNb].uMax = sMax;

    double uMin = inDirectPath->attArcLengthManager->defaultParam(sMin);
    double uMax = inDirectPath->attArcLengthManager->defaultParam(sMax);
    // Get maximal norm of gamma first derivative over interval.
    inDirectPath->attBoundManagerDefParam->getBoundsNormGamma1(uMin, uMax, minGamma1, maxGamma1);
    // Get maximal norm of gamma second derivative over interval.
    inDirectPath->attBoundManagerDefParam->getBoundsNormGamma2(uMin, uMax, minGamma2, maxGamma2);
    // Get maximal norm of gamma second derivative over interval.
    maxGamma3 = inDirectPath->attBoundManagerDefParam->getBoundsNormGamma3();

    // Get maximal absolute value of du/ds.
    double maxAbsDuOverDs = arcLengthToDefaultMappingIter->maxAbsDeriv1();
    // Get maximal absolute value of d^2u/ds^2.
    double maxAbsD2uOverDs2 = arcLengthToDefaultMappingIter->maxAbsDeriv2();
    // Get maximal absolute value of d^3u/ds^3.
    double maxAbsD3uOverDs3 = arcLengthToDefaultMappingIter->maxAbsDeriv3();

    attMaxD3gammaOverDs3 =
      maxGamma3*pow(maxAbsDuOverDs, 2.0) +
      3*maxGamma2*maxAbsD2uOverDs2*maxAbsDuOverDs +
      maxGamma1*maxAbsD3uOverDs3;

    //
    // Computation of dgamma/ds and d^2gamma/ds^2 norms at sMin
    //

    // First and second derivatives of gamma (wrt u) at uMin
    double xDgammaOverDu, yDgammaOverDu, xD2gammaOverDu2, yD2gammaOverDu2;
    if (inDirectPath->gammaDeriv1and2(uMin, xDgammaOverDu, yDgammaOverDu,
                                      xD2gammaOverDu2,yD2gammaOverDu2) != KD_OK)
    {
      cerr << "CflicBoundManagerArcLengthParam::buildBoundVectors: unable to compute gamma derivatives"
      << endl;
      return KD_ERROR;
    }
    // First and second derivatives of u wrt s at sMin.
    double duOverDs = arcLengthToDefaultMappingIter->valueDeriv(sMin);
    double d2uOverDs2 = arcLengthToDefaultMappingIter->valueDeriv2(sMin);

    // Vector dgamma/ds at Smin
    double xDgammaOverDs = xDgammaOverDu*duOverDs;
    double yDgammaOverDs = yDgammaOverDu*duOverDs;

    // Norm of vector dgamma/ds at Smin
    double normDgammaOverDsSmin = sqrt(pow(xDgammaOverDs ,2.0) + pow(yDgammaOverDs ,2.0));

    // Vector d^2gamma/ds^2 at Smin
    double xD2gammaOverDs2 = pow(duOverDs, 2.0)*xD2gammaOverDu2 + d2uOverDs2*xDgammaOverDu;
    double yD2gammaOverDs2 = pow(duOverDs, 2.0)*yD2gammaOverDu2 + d2uOverDs2*yDgammaOverDu;

    // Norm of vector d^2gamma/ds^2 at Smin
    double normD2gammaOverDs2Smin = sqrt(pow(xD2gammaOverDs2, 2.0) + pow(yD2gammaOverDs2, 2.0));

    //
    // Computation of of dgamma/ds and d^2gamma/ds^2 norms at sMax
    //

    // First and second derivatives of gamma (wrt u) at uMax
    if (inDirectPath->gammaDeriv1and2(uMax, xDgammaOverDu, yDgammaOverDu,
                                      xD2gammaOverDu2,yD2gammaOverDu2) != KD_OK)
    {
      cerr << "CflicBoundManagerArcLengthParam::buildBoundVectors: unable to compute gamma derivatives"
      << endl;
      return KD_ERROR;
    }
    // First and second derivatives of u wrt s at sMax.
    duOverDs = arcLengthToDefaultMappingIter->valueDeriv(sMax);
    d2uOverDs2 = arcLengthToDefaultMappingIter->valueDeriv2(sMax);

    // Vector dgamma/ds at Smax
    xDgammaOverDs = xDgammaOverDu*duOverDs;
    yDgammaOverDs = yDgammaOverDu*duOverDs;

    // Norm of vector dgamma/ds at Smax
    double normDgammaOverDsSmax = sqrt(pow(xDgammaOverDs ,2.0) + pow(yDgammaOverDs ,2.0));

    xD2gammaOverDs2 = pow(duOverDs, 2.0)*xD2gammaOverDu2 + d2uOverDs2*xDgammaOverDu;
    yD2gammaOverDs2 = pow(duOverDs, 2.0)*yD2gammaOverDu2 + d2uOverDs2*yDgammaOverDu;

    // Norm of vector d^2gamma/ds^2 at Smax
    double normD2gammaOverDs2Smax = sqrt(pow(xD2gammaOverDs2, 2.0) + pow(yD2gammaOverDs2, 2.0));

    //
    // Lower and upper bounds of second derivative.
    //

    if (CflicManager::computeFunctionBoundsFromDerivativeUpperBound(boundVectorDeriv2[iterNb], normD2gammaOverDs2Smin,
        normD2gammaOverDs2Smax, attMaxD3gammaOverDs3) != KD_OK)
    {
      return KD_ERROR;
    }

    //
    // Lower and upper bounds of first derivative.
    //

    double maxD2gammaOverds2 = boundVectorDeriv2[iterNb].valueMax;

    if (CflicManager::computeFunctionBoundsFromDerivativeUpperBound(boundVectorDeriv1[iterNb], normDgammaOverDsSmin,
        normDgammaOverDsSmax, maxD2gammaOverds2) != KD_OK)
    {
      return KD_ERROR;
    }
    // Test that minimum value of norm of gamma first derivative is positive.
    if (boundVectorDeriv1[iterNb].valueMin <= 0.5)
    {
      return KD_ERROR;
    }
    arcLengthToDefaultMappingIter++;
  }
  return KD_OK;
}

void CflicBoundManagerArcLengthParam::getBoundsOnInterval(const std::vector<TflicBoundInterval>& boundIntVector,
    double sMin, double sMax,
    double& valueMin, double& valueMax)
{
  unsigned int sampleIntervalId;
  unsigned int sampleIntervalIdSmin = (unsigned int)floor(sMin*attNbSampleIntervals/attArcLength);
  unsigned int sampleIntervalIdSmax = (unsigned int)floor(sMax*attNbSampleIntervals/attArcLength);

  if (sampleIntervalIdSmin == attNbSampleIntervals)
  {
    sampleIntervalIdSmin = attNbSampleIntervals-1;
  }
  if (sampleIntervalIdSmax == attNbSampleIntervals)
  {
    sampleIntervalIdSmax = attNbSampleIntervals-1;
  }
  valueMin = boundIntVector[sampleIntervalIdSmin].valueMin;
  valueMax = boundIntVector[sampleIntervalIdSmin].valueMax;

  for (sampleIntervalId = sampleIntervalIdSmin;
       sampleIntervalId <= sampleIntervalIdSmax;
       sampleIntervalId++)
  {
    if (valueMin > boundIntVector[sampleIntervalId].valueMin)
    {
      valueMin = boundIntVector[sampleIntervalId].valueMin;
    }
    if (valueMax < boundIntVector[sampleIntervalId].valueMax)
    {
      valueMax = boundIntVector[sampleIntervalId].valueMax;
    }
  }
}


// ==============================================================================
//
//  METHOD OF CLASS CflicDirectPath
//
// ==============================================================================



/*****************************************
 PUBLIC METHODS
*****************************************/

// =========================================================================================

// ==============================================================================
//
//  METHOD OF CLASS CflicPolynomial3
//
// ==============================================================================

CflicDirectPath::~CflicDirectPath()
{
  //------debug
  //cout << "flat DP destructor de x1= " << flatStartCfg.xp << " \ty1= " <<  flatStartCfg.yp  <<" \tT1= " <<  flatStartCfg.tau
  //     <<" \tK1= " <<  flatStartCfg.kappa  << endl
  //     << "\t\tA x2= " <<flatEndCfg.xp << " \ty2= " <<  flatEndCfg.yp<< " \tT2= "
  //     <<  flatEndCfg.tau << " \tK2= " <<  flatEndCfg.kappa<< endl << endl ;
  //--------------------------------------
}

// =========================================================================================

CflicDirectPathShPtr CflicDirectPath::create(const CkwsConfig &inStartCfg,
					     const CkwsConfig &inEndCfg,
					     const CkwsSteeringMethodShPtr &inSteeringMethod,
					     bool inOriented)
{

  CflicDirectPath* pathPtr = new CflicDirectPath(inStartCfg, inEndCfg,inSteeringMethod);
  CflicDirectPathShPtr pathShPtr(pathPtr);
  CflicDirectPathWkPtr pathWkPtr(pathShPtr) ;

  // Create derivative bound manager for default parameter.
  if (pathShPtr)
  {
    CflicBoundManagerDefParamShPtr boundManager(new CflicBoundManagerDefParam(pathShPtr,inStartCfg, inEndCfg));
    pathShPtr->attBoundManagerDefParam = boundManager;
    if ( (pathShPtr->attBoundManagerDefParam->buildBoundLists()) == KD_ERROR)
    {
      pathShPtr.reset();
    }
  }

  // Create arc length manager (shared pointer) that compute the mappings between default and arc-length
  // parameter and inverse mapping.
  if (pathShPtr)
  {
    CflicArcLengthManagerShPtr arcLengthManager(new CflicArcLengthManager(pathShPtr->attBoundManagerDefParam->attMaxNbIntervals,pathShPtr));

    pathShPtr->attArcLengthManager = arcLengthManager;
  }

  // Create derivative bound manager for arc-length parameter.
  if (pathShPtr)
  {
    CflicBoundManagerArcLengthParamShPtr
    boundManagerAL(new CflicBoundManagerArcLengthParam(pathShPtr->attBoundManagerDefParam->attMaxNbIntervals,
                   pathShPtr->attArcLengthManager->attArcLength,
                   pathShPtr));
    pathShPtr->attBoundManagerArcLengthParam = boundManagerAL;
    if ((pathShPtr->attBoundManagerArcLengthParam->buildBoundVectors(pathShPtr)) == KD_ERROR)
    {
      pathShPtr.reset();
    }
  }

  // Init should be at the end since CkwsDirectPath::init() calls computePrivateLength that is defined by
  // attArcLengthManager
  if (pathShPtr) {
    if (pathPtr->init(pathWkPtr, inOriented) != KD_OK) {
      pathShPtr.reset()	;
    }
  }

  if (!pathShPtr)
  {
    //cerr << " \\\\ CflicDirectPath::create failed //// " << endl ;
    //cerr << "init : " << inStartCfg << endl;
    //cerr << "end : "  << inEndCfg << endl ;
  }
  else
  {
    // debug
    // cout << "================= CflicDirectPath::create succeeded ===============================" << endl;
    // cout << "init : " << inStartCfg << endl;
    // cout << "end : "  << inEndCfg << endl ;
    // -----------
  }

  return pathShPtr ;
}

// =========================================================================================

CflicDirectPathShPtr CflicDirectPath::createCopy(const CflicDirectPathConstShPtr &inFlicDirectPath)
{

  if(inFlicDirectPath != NULL)
  {
    CflicDirectPath* pathPtr = new CflicDirectPath(*inFlicDirectPath) ;
    CflicDirectPathShPtr pathShPtr(pathPtr) ;
    CflicDirectPathWkPtr pathWkPtr(pathShPtr) ;

    if(pathPtr->init(pathWkPtr) != KD_OK)
    {
      pathShPtr.reset() ;
      return pathShPtr;
    }
    // Copy of attributes attBoundManagerDefParam, attArcLengthManager, attBoundManagerArcLengthParam.
    if (inFlicDirectPath->attBoundManagerDefParam)
    {
      pathShPtr->attBoundManagerDefParam = inFlicDirectPath->attBoundManagerDefParam;
    }
    else
    {
      cerr << "CflicDirectPath::createCopy: attBoundManagerDefParam does not exist in the copied direct path." << endl;
    }

    if (inFlicDirectPath->attArcLengthManager)
    {
      pathShPtr->attArcLengthManager = inFlicDirectPath->attArcLengthManager;
    }
    else
    {
      cerr << "CflicDirectPath::createCopy: attArcLengthManager does not exist in the copied direct path." << endl;
    }

    if (inFlicDirectPath->attBoundManagerArcLengthParam)
    {
      pathShPtr->attBoundManagerArcLengthParam = inFlicDirectPath->attBoundManagerArcLengthParam;
    }
    else
    {
      cerr << "CflicDirectPath::createCopy: attBoundManagerArcLengthParam does not exist in the copied direct path." << endl;
    }

    return pathShPtr;

  }
  else return CflicDirectPathShPtr() ;

}

// =========================================================================================

CkwsAbstractPathShPtr CflicDirectPath::clone() const
{

  return CflicDirectPath::createCopy(m_weakPtr.lock());

}

/*****************************************
 PROTECTED METHODS
*******************************************/


// =========================================================================================

CflicDirectPath::CflicDirectPath(const CkwsConfig &inStartCfg, const CkwsConfig &inEndCfg,
                                 const CkwsSteeringMethodShPtr &inSteeringMethod) :
    CkwsPlusDirectPath(inStartCfg, inEndCfg, inSteeringMethod)
{
  //configuration convertion
  flatStartCfg.kappa = inStartCfg.dofValue(CURV_COORD) ; //Kappa (dof fictif)
  flatStartCfg.xp = inStartCfg.dofValue(X_COORD) ;  // x
  flatStartCfg.yp = inStartCfg.dofValue(Y_COORD) ;  // y
  flatStartCfg.tau = inStartCfg.dofValue(RZ_COORD) ; // theta

  flatEndCfg.kappa = inEndCfg.dofValue(CURV_COORD) ; //Kappa (dof fictif)
  flatEndCfg.xp = inEndCfg.dofValue(X_COORD) ;  // x
  flatEndCfg.yp = inEndCfg.dofValue(Y_COORD) ;  // y
  flatEndCfg.tau = inEndCfg.dofValue(RZ_COORD) ; // theta

  attFlatV2 = computeFlatV2(&flatStartCfg, &flatEndCfg);
  attMaxCurvature = max(fabs(inStartCfg.device()->dof(CURV_COORD)->vmin()),
			fabs(inStartCfg.device()->dof(CURV_COORD)->vmax()));

  // debug
  //cout << "Constructor by configurations" << endl;
  // ---------------------
}

CflicDirectPath::CflicDirectPath(const CflicDirectPath &inDirectPath):CkwsPlusDirectPath(inDirectPath)
{
  //configuration convertion
  flatStartCfg.kappa = privateStart().dofValue(CURV_COORD) ; //Kappa (dof fictif)
  flatStartCfg.xp = privateStart().dofValue(X_COORD) ;  // x
  flatStartCfg.yp = privateStart().dofValue(Y_COORD) ;  // y
  flatStartCfg.tau = privateStart().dofValue(RZ_COORD) ; // theta

  flatEndCfg.kappa = privateEnd().dofValue(CURV_COORD) ; //Kappa (dof fictif)
  flatEndCfg.xp = privateEnd().dofValue(X_COORD) ;  // x
  flatEndCfg.yp = privateEnd().dofValue(Y_COORD) ;  // y
  flatEndCfg.tau = privateEnd().dofValue(RZ_COORD) ; // theta

  attFlatV2 = inDirectPath.flatV2();
  attMaxCurvature = inDirectPath.attMaxCurvature;

  // debug
  // cout << "Copy constructor" << endl;
  // ------------------------
}

// =========================================================================================

ktStatus CflicDirectPath::init(const CflicDirectPathWkPtr &inWeakPtr)
{

  ktStatus success = CkwsDirectPath::init(inWeakPtr) ;

  if (KD_OK == success) m_weakPtr = inWeakPtr;

  return success ;

}

// =========================================================================================

ktStatus CflicDirectPath::init(const CflicDirectPathWkPtr &inWeakPtr, bool inOriented)
{

  ktStatus success = CkwsDirectPath::init(inWeakPtr) ;

  if (inOriented && attFlatV2 <= 0)
  {
    success = KD_ERROR;
  }

  if (KD_OK == success) m_weakPtr = inWeakPtr;

  return success ;

}

// =========================================================================================

double CflicDirectPath::computePrivateLength()const
{

  //debug
  //cout << "enter in computePrivateLength " << endl ;
  //------------------------
  
  return attArcLengthManager->attArcLength;
}

// =========================================================================================

void CflicDirectPath::interpolateDefaultParam(double u, CkwsConfig & outCfg) const
{

  KWS_PRECONDITION( privateStart().size() == device()->countDofs() );
  KWS_PRECONDITION( privateStart().size() == outCfg.size() );

#if 0
  double theta, K;
#endif
  int deriv_order = 2 ;
  double Tab_gamma[6] ;
  TflatConfig f1, f2 ;

  f1.kappa = privateStart().dofValue(CURV_COORD) ; //Kappa (dof fictif)
  f1.xp = privateStart().dofValue(X_COORD) ;  // x
  f1.yp = privateStart().dofValue(Y_COORD) ;  // y
  f1.tau = privateStart().dofValue(RZ_COORD) ; // theta


  f2.kappa = privateEnd().dofValue(CURV_COORD) ; // Kappa (dof fictif)
  f2.xp = privateEnd().dofValue(X_COORD) ; //  x
  f2.yp = privateEnd().dofValue(Y_COORD) ; //  y
  f2.tau = privateEnd().dofValue(RZ_COORD); // theta


  // compute the Tflatconfiguration corresponding to the i
  CflicManager::flatCombination(&f1, &f2, u, attFlatV2, deriv_order, Tab_gamma) ;

  int forward = (attFlatV2 > 0 ? true : false);
  TflatConfig flatConfig;


  CflicManager::flatConvDerivFlatconfig(Tab_gamma, &flatConfig, forward);

  outCfg.beginChange();

  outCfg.dofValue(CURV_COORD, flatConfig.kappa) ; // kappa
  outCfg.dofValue(X_COORD, flatConfig.xp) ; //  px
  outCfg.dofValue(Y_COORD, flatConfig.yp) ; //  py
  outCfg.dofValue(Z_COORD, 0) ; //  pz
  outCfg.dofValue(RX_COORD, 0) ; //  
  outCfg.dofValue(RY_COORD, 0) ; //  
  outCfg.dofValue(RZ_COORD, flatConfig.tau ) ;       //  theta


  outCfg.endChange() ;


}

void CflicDirectPath::interpolate(double s, CkwsConfig & outCfg) const
{

  KWS_PRECONDITION( privateStart().size() == device()->countDofs() );
  KWS_PRECONDITION( privateStart().size() == outCfg.size() );

  double u = attArcLengthManager->defaultParam(s);
  interpolateDefaultParam(u, outCfg);
}


// ==========================================================================================

void CflicDirectPath::maxAbsoluteDerivDefaultParam(double inFrom, double inTo, std::vector<double> & outVectorDeriv) const
{
  //debug
  //cout << " - MAX ABSOLUTE DERIVATE - " << endl ;
  //-----------------------------------------

  KWS_PRECONDITION( privateStart().size() == device()->countDofs() );

  CkwsDeviceShPtr dev(device());
  outVectorDeriv.resize(dev->countDofs()); // that causes error with 2.04
  // outVectorDeriv.resize(privateStart().size());

  double mini2 = 1 , max2 =1 , mini1 =1   , max1 =1 ;
  attBoundManagerDefParam->getBoundsOnInterval(attBoundManagerDefParam->getBoundListDeriv2(), inFrom,  inTo,  mini2,  max2) ;
  attBoundManagerDefParam->getBoundsOnInterval(attBoundManagerDefParam->getBoundListDeriv1(), inFrom,  inTo,  mini1,  max1) ;
  double max3 = attBoundManagerDefParam->getUpperBoundGamma3();


  //debug
  // cout << "De " <<  inFrom << " a " << inTo << " maxDerivX : " << max1 << "\t maxDerivY : " << max1
  //<< "\t maxDerivT : " << max2/mini1 << " \tmax2 :" << max2 << " \tmini 1 :" << mini1  << endl ;
  //-------------------------------------------------

  outVectorDeriv[0] = max3/pow(mini1,2) + 3*max2/pow(mini1,3); // kappa
  outVectorDeriv[1] = max1  ; // x
  outVectorDeriv[2] = max1  ; // y
  outVectorDeriv[3] = max2/mini1 ; // theta

  //debug
  //cout << " - MAX ABSOLUTE DERIVATE - " << endl ;
  //------------------------------

}

// ==========================================================================================

void CflicDirectPath::maxAbsoluteDerivative(double inFrom, double inTo, std::vector<double> & outVectorDeriv) const
{
  KWS_PRECONDITION( privateStart().size() == device()->countDofs() );

  CkwsDeviceShPtr dev(device());
  outVectorDeriv.resize(dev->countDofs()); // that causes error with 2.04
  // outVectorDeriv.resize(privateStart().size());

  double max3 = attBoundManagerArcLengthParam->maxD3gammaOverDs3();
  double min2 = 1 , max2 =1 , min1 =1   , max1 =1 ;

  attBoundManagerArcLengthParam->getBoundsNormDgammaOverDs(inFrom, inTo, min1, max1);
  attBoundManagerArcLengthParam->getBoundsNormD2gammaOverDs2(inFrom, inTo, min2, max2);

  // Device is now a freeflyer. 
  // Set non planar dof values to very small value (0 could lead to troubles).

  outVectorDeriv[0] = max3/pow(min1,2) + 3*max2/pow(min1,3); // kappa
  outVectorDeriv[1] = max1  ;     // x
  outVectorDeriv[2] = max1  ;     // y
  outVectorDeriv[3] = 1e-10;        // z
  outVectorDeriv[4] = 1e-10;        // Rx
  outVectorDeriv[5] = 1e-10;        // Ry
  outVectorDeriv[6] = max2/min1 ; // Rz
}


// ==========================================================================================


double CflicDirectPath::normGammaDeriv1(double u)
{
  double v2;
  int deriv_order = 2 ;
  double Tab_gamma[6] ;
  TflatConfig f1, f2 ;
  double normDeriv;

  f1.kappa = privateStart().dofValue(CURV_COORD) ; //Kappa (dof fictif)
  f1.xp = privateStart().dofValue(X_COORD) ;  // x
  f1.yp = privateStart().dofValue(Y_COORD) ;  // y
  f1.tau = privateStart().dofValue(RZ_COORD) ; // theta


  f2.kappa = privateEnd().dofValue(CURV_COORD) ; // Kappa (dof fictif)
  f2.xp = privateEnd().dofValue(X_COORD) ; //  x
  f2.yp = privateEnd().dofValue(Y_COORD) ; //  y
  f2.tau = privateEnd().dofValue(RZ_COORD); // theta


  // compute the Tflatconfiguration corresponding to the i
  v2 = attFlatV2;
  CflicManager::flatCombination(&f1, &f2, u, attFlatV2, deriv_order, Tab_gamma) ;

  normDeriv = sqrt(pow(Tab_gamma[2],2.0) + pow(Tab_gamma[3],2.0));

  return normDeriv;
}

// ==========================================================================================


ktStatus CflicDirectPath::gammaDeriv1and2(double u, double& xGamma_1, double& yGamma_1,
    double& xGamma_2, double& yGamma_2)
{
  int deriv_order = 2 ;
  double Tab_gamma[6] ;
  TflatConfig f1, f2 ;

  f1.kappa = privateStart().dofValue(CURV_COORD) ; //Kappa (dof fictif)
  f1.xp = privateStart().dofValue(X_COORD) ;  // x
  f1.yp = privateStart().dofValue(Y_COORD) ;  // y
  f1.tau = privateStart().dofValue(RZ_COORD) ; // theta


  f2.kappa = privateEnd().dofValue(CURV_COORD) ; // Kappa (dof fictif)
  f2.xp = privateEnd().dofValue(X_COORD) ; //  x
  f2.yp = privateEnd().dofValue(Y_COORD) ; //  y
  f2.tau = privateEnd().dofValue(RZ_COORD); // theta


  // compute the Tflatconfiguration corresponding to the i
  CflicManager::flatCombination(&f1, &f2, u, attFlatV2, deriv_order, Tab_gamma) ;

  xGamma_1 = Tab_gamma[2];
  yGamma_1 = Tab_gamma[3];
  xGamma_2 = Tab_gamma[4];
  yGamma_2 = Tab_gamma[5];

  return KD_OK;
}

/****************************************************
 EXTERN FUNCTION USE TO COMPUTE FLAT INTERPOLATION
****************************************************/

//=========================================================================================

double CflicDirectPath::computeFlatV2(TflatConfig *fconf1, TflatConfig *fconf2)
{
  double O1M1_x, O1M1_y, O1M2_x, O1M2_y, v2;

  double teta, kappa, Phi, cosinus;
  double norme_O1M1, norme_O1M2, scalaire_O1M1_O1M2;

  teta = fconf1->tau;
  kappa = fconf1->kappa;

  /* First canonical curve is a circle */
  if(fabs(kappa) > NEAR_ZERO)
  {

    O1M1_x = sin(teta)/kappa;
    O1M1_y = -cos(teta)/kappa;

    O1M2_x = fconf2->xp - fconf1->xp + sin(teta)/kappa;
    O1M2_y = fconf2->yp - fconf1->yp - cos(teta)/kappa;

    scalaire_O1M1_O1M2 = O1M1_x*O1M2_x + O1M1_y*O1M2_y;
    norme_O1M1 = sqrt(O1M1_x*O1M1_x + O1M1_y*O1M1_y);
    norme_O1M2 = sqrt(O1M2_x*O1M2_x + O1M2_y*O1M2_y);
    cosinus = scalaire_O1M1_O1M2 / (norme_O1M1*norme_O1M2);
    if (fabs(cosinus) >= 1)
    {
      /* kappa is in fact very small :
      return the same value as in the line case
      */
      v2 = (fconf2->xp - fconf1->xp)*cos(teta) +
           (fconf2->yp - fconf1->yp)*sin(teta);
      return(v2);
    }
    else
    {
      Phi = acos(scalaire_O1M1_O1M2 / (norme_O1M1*norme_O1M2));
    }
    if((O1M2_x*cos(teta) + O1M2_y*sin(teta)) < 0.0) Phi *= -1.0;

    v2 = Phi/fabs(kappa);
    return(v2);
  }
  /* La premiere conf definie une droite */
  else
  {
    v2 = (fconf2->xp - fconf1->xp)*cos(teta) +
         (fconf2->yp - fconf1->yp)*sin(teta);
    return(v2);
  }
}


